---
title: "ChainLadder Package: Mack and Boot Projections"
author: "Andy Merlino"
date: "2015-02-23"
output: html_document
runtime: shiny
fontsize: 12pt
geometry: margin=1.25in
---

# Purpose

Measure the accuracy of the `ChainLadder::MackChainLadder()` and `ChainLadder::BootChainLadder()` reserve projection functions by comparing the projected reserves to actual insurance losses.

# ChainLadder Package

The `ChainLadder` package by Markus Gesmann, Dan Murphy, and Wayne Zhang includes methods for projecting insurance loss reserves.  The Mack and Boot reserve projections are calculated by the `ChainLadder` functions, `MackChainLadder()` and `BootChainLadder()`.  `MackChainLadder()` provides a distribution free calculation of the standard error for the standard chain ladder reserve projection.  `BootChainLadder()` uses bootstap resampling to determine the standard error of the reserve projection.  For more information please see the `ChainLadder` [package vignette](http://cran.r-project.org/web/packages/ChainLadder/vignettes/ChainLadder.pdf).  

# Data

The CAS website provides historic U.S. insurance loss data across 6 different lines of business and many different companies.  Data from origin years 1988 through 1997 evaluated as of 1997 (i.e. the upper left triangle of losses) is used to run the `ChainLadder` projections.  The CAS data sets include actual losses developed for 10 years for all the provided origin years.  The CAS data sets include data from the following lines of business:

* Workers' Compensation
* Private Passenger Auto
* Commercial Auto
* Medical Malpractice
* Other Liability
* Product liability

For more information on the data see the [CAS webpage](http://www.casact.org/research/index.cfm?fa=loss_reserves_data).

```{r packages_data, message = FALSE, echo = FALSE}
library(ChainLadder) # install.packages("ChainLadder")
library(dplyr) # for data manipulation
library(reshape2) # data manipulation
library(ggplot2) # graphics
library(xtable) # tables
options(xtable.comment = FALSE)
options(xtable.type = "html")

# package I created to store CAS data
library(casdata) # devtools::install_github("merlinoa/casdata")
paid_cutoff <- 200
```

### A little data cleaning

Several companies were removed from the analysis for various reasons.  The most common reason I removed a company from the analysis was that it had incomplete loss information.  To see all the code used to clean the data see the [.Rmd file on github](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd).

The following table breaks down the number of companies included in this study by line of business.

```{r data_cleaning, echo = FALSE, results = "asis"}
# identify unique companies that have missing data.
# I also had some trouble with companies that had very small losses, so I decided
# to remove all companies with cumulative paid losses less than some value 
# at any observation in the data set.
# GRCODE is only unique by lob, so I need to create new column with combination of

df <- mutate(losses, id = paste(lob, gr_code, sep = "_"))
  
id_missing <- unique(df$id[df[, "paid"] <= paid_cutoff])

# remove companies that have missing data
df <- df[-which(df$id %in% id_missing), ]

df_out <- group_by(df, lob) %>%
  summarise(companies = length(unique(gr_code)))

names(df_out) <- c("LOB", "Num of Companies")
df_out$LOB <- c("Commercial Auto", "Medical Malpractice",
                "Other Liabiltiy", "Private Passenger",
                "Product Liability", "Workers Compensation")

df_out <- xtable(as.data.frame(df_out))

print(df_out,
      include.rownames = FALSE)
```

# Analysis

The analysis runs the `MackChainLadder` and `BootChainLadder` reserve projection functions on each company.  I then identify what the true reserve should have been and subtract the projected reserve amount from the true reserve, then divide that by the standard error estimated by the `ChainLadder` reserving function.

Several steps are invloved in creating the desired visualizations from the cleaned data.  View the [code](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd) for details.

```{r create_triangles, echo = FALSE}
# function: to create triangles for each company
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
triangles <- function(data, loss_type) {

 # find unique GRCODEs for looping
 unique_id <- unique(data$id)
 
 # create triangles for each company using `ChainLadder` package
 tri <- vector("list", length(unique_id))
 for (i in seq_along(unique_id)) {
   tri[[i]] <- as.triangle(data[data$id == unique_id[i] & 
                                      data$origin + 
                                      data$dev < 1999, ], 
                               origin = "origin", 
                               dev = "dev", 
                               value = loss_type)
 }
 # set name of each triangle to the id
 names(tri) <- unique_id
 tri
}

# use above functions to create paid and incurred triangles for all lines
# of business
paid_triangles <- triangles(df ,loss_type = "paid")
incurred_triangles <- triangles(df, loss_type = "incurred")
```

```{r projections_functions, echo = FALSE, warning = FALSE}
# function for mack and boot projections============================================
# param triangles list of all company triangles
# param method character "MackChainLadder" or "BootChainLadder"
projection <- function(triangles, method) {
  # run mack model as provided in ChainLadder package 
  projections <- lapply(triangles, method)
  
  # extract the good stuff from the boot projection
  smry <- vector("list", length(projections))
  for (i in seq_along(projections)) {
    smry[[i]] <- summary(projections[[i]])[[2]]
  }

  smry <- as.data.frame(t(as.data.frame(smry)))
  rownames(smry) <- NULL
  smry <- data.frame(names(triangles), smry)
  smry$lob <- gsub("_.*$", "", smry[, 1])
  smry
}
```

```{r projection_actual_join, echo = FALSE}
# function: to find the sum of actual losses for all origin years for 
# each insurance company after 10 development periods
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
actual_ultimate <- function(data, loss_type) {
  # find actual losses at development period 10
  dev_10 <- data[data$dev == 10, ]
  dev_10_sum <- as.data.frame(tapply(dev_10[, loss_type], dev_10$id,  sum))
  dev_10_sum$id <- rownames(dev_10_sum)
  names(dev_10_sum)[1] <- paste0(loss_type, "_ultimate")
  dev_10_sum
}

# run function to find actual ultimates for all companies
paid_actual_ultimate <- actual_ultimate(df, loss_type = "paid")
incurred_actual_ultimate <- actual_ultimate(df, loss_type = "incurred")

# group actual losses with mack projections
projection_actual_join <- function(projection_smry, actual) {
  smry <- left_join(projection_smry, actual, by = "id", copy = TRUE)
  names(smry)[length(smry)] <- "actual_ultimate"
  # calculate z value
  smry$actual_ibnr <-  smry$actual_ultimate - smry$latest
  smry$z = (smry$actual_ibnr - smry$ibnr) / smry$se
  smry
}
```

## Histograms

```{r mack, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# calculate mack projections and grab summary
paid_mack_smry <- projection(paid_triangles, 
                             method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(paid_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_mack_smry <- projection(incurred_triangles, 
                                 method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(incurred_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_mack_full <- projection_actual_join(paid_mack_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_mack_full <- projection_actual_join(incurred_mack_smry, 
                                      incurred_actual_ultimate)
```

```{r boot_projections, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# caculate and return summary info for bootstrap method
paid_boot_smry <- projection(paid_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(paid_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_boot_smry <- projection(incurred_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(incurred_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_boot_full <- projection_actual_join(paid_boot_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_boot_full <- projection_actual_join(incurred_boot_smry, 
                                      incurred_actual_ultimate)

selectInput("projection", "Projection", 
            choices = list("Mack - Paid" = "mack_paid", 
                           "Mack - Incurred" = "mack_incurred",
                           "Boot - Paid" = "boot_paid", 
                           "Boot - Incurred" = "boot_incurred"))

selectInput("lob", "Lines of Business", 
            choices = list("Workers' Compensation" = "wkcomp",
                           "Commercial Auto" = "comauto",
                           "Medical Malpractice" = "medmal",
                           "Other Liability" = "othliab",
                           "Private Passenger Auto" = "ppauto",
                           "Product Liability" = "prodliab"),
            multiple = TRUE,
            selected = "Workers' Compensation")

selected_data <- reactive({
  hold <- switch(input$projection,
         "mack_paid" = paid_mack_full,
         "mack_incurred" = incurred_mack_full,
         "boot_paid" = paid_boot_full,
         "boot_incurred" = incurred_boot_full
         )
  hold[hold$lob %in% input$lob,]
})

# plot paid mack z values
renderPlot({
  ggplot(selected_data(), aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle(paste(input$projection, input$lob)) +
       geom_bar()
})

```

# Initial Take Aways

Both the Mack and Boot paid reserve projections appear to slightly underestimate the actual reserve.  Several factors including inflation could be responsible for this underestimation.

The incurred reserve projections tend to have more projections within 1 and 2 standard errors of the actual reserve than the paid projections.

The `BootChainLadder()` function on incurred losses gave a significantly more accurate reserve projections than you would expect if the projection was normally distributed around the true mean.