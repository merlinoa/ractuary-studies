---
title: "ChainLadder Package in Action"
author: "Andy Merlino"
date: "Wednesday, December 3, 2014"
output: 
    pdf_document:
        includes:
            in_header: mystyles.sty
fontsize: 12pt
geometry: margin=1in
---

# Background

The `ChainLadder` package includes methods for projecting insurance loss reserves.  For more information about the `ChainLadder` package please see the `ChainLadder` [package vignette](http://cran.r-project.org/web/packages/ChainLadder/vignettes/ChainLadder.pdf).  

# Purpose

This document aims to measure the accuracy of the different reserving methods available in the `ChainLadder` package by comparing the package projections to actual insurance loss data.

# Data

The CAS website provides historic U.S. insurance loss data accross 6 different lines of business and many different companies.  The data includes complete triangles from origin years 1988 through 1997.  We will use data from origin years 1988 through 1997 evaluated as of 1997 to run the `ChainLadder` projections.  The data will be projected out to the 10th development year and compared to actual loss data at that time.  The CAS data sets include data from the following lines of business:

* Workers' Compensation
* Private Passenger Auto
* Commercial Auto
* Medical Malpractice
* Other Liability
* Product liability

For more information on the data see the [CAS webpage](http://www.casact.org/research/index.cfm?fa=loss_reserves_data).

```{r packages_data, message = FALSE, echo = FALSE}
library(ChainLadder) # install.packages("ChainLadder")
library(dplyr) # for data manipulation
library(reshape2) # data manipulation
library(xtable)
options(xtable.comment = FALSE)

# package I created to store CAS data
library(casdata) # devtools::install_github("merlinoa/casdata")
# package I created to transform ChainLadder classes into
# data frames that can be easily printed to pdf
library(exhibit) # devtools::install_github("merlinoa/exhibit")
small_cut <- 200 # for small loss amounts cut off size
```

### A little data cleaning

A good portion of the companies in the data sets are missing loss information for a portion of the origin years (e.g for workers compensation 70 out of 132 do not have loss information for all origin years at all development periods).  In addition to companies with missing loss information we removed companies any cumulative with paid loss amounts less than `r small_cut`. To see all the code used to clean the data and all code used in the analysis see the [.Rmd file on github](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd).

```{r data_cleaning, echo = FALSE}
# Combine data sets into a list 
data_sets <- list(wkcomp, ppauto, prodliab, comauto, medmal, othliab)

# identify unique companies in each data set that have missing data
# I also had some trouble with companies that had very small losses, so I decided
# to remove all companies with cumulative paid losses less than some value 
# at any observation in the data set.
id_missing_data <- lapply(data_sets, function(x) unique(x$GRCODE[x[, 7] <= small_cut]))

# remove companies that have missing data
for (i in seq_along(data_sets)) {
  data_sets[[i]] <- data_sets[[i]][-which(data_sets[[i]]$GRCODE %in% 
                                            id_missing_data[[i]]), ]
}
```

# Analysis

Several steps are invloved in creating the desired visualizations from the cleaned data.  An example of each of these steps is outlined in \hyperref[appendix:a]{Appendix A}(Appendix A) for the Mack Method on paid workers' compensation losses. 

```{r create_triangles, echo = FALSE}
# param lob the cleaned insurance loss data frame
# param loss_type character "paid" or "incurred"
triangles <- function(lob, loss_type) {

 # find unique GRCODEs for looping
 lob_id <- unique(lob$GRCODE)

 loss_col_name <- if (loss_type == "paid") {
   names(lob)[7]
 } else {
   names(lob)[6]
 }
 
 # create triangles for each company using `ChainLadder` package
 tri <- vector("list", length(lob_id))
 for (i in seq_along(lob_id)) {
   tri[[i]] <- as.triangle(lob[lob$GRCODE == lob_id[i] & 
                                      lob$AccidentYear + 
                                      lob$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = loss_col_name)
 }
 names(tri) <- lob_id
 tri
}

# use above functions to create paid and incurred triangles for all lines 
# of business
paid_triangles <- lapply(data_sets, triangles, loss_type = "paid")
incurred_triangles <- lapply(data_sets, triangles, loss_type = "incurred")
```

```{r mack_projections, echo = FALSE, warning = FALSE}
# function for mack
# param lob_triangles object returned from above functions
mack_f <- function(lob_triangle) {
  # run mack model as provided in ChainLadder package
  lob_mack <- lapply(lob_triangle, MackChainLadder, est.sigma = "Mack")
  
  # extract the good stuff from the mack projection
  mack_smry <- vector("list", length(lob_mack))
  for (i in seq_along(lob_mack)) {
    mack_smry[[i]] <- summary(lob_mack[[i]])[[2]]$Totals[c(1, 3:5)]
  }

  mack_smry <- as.data.frame(t(as.data.frame(mack_smry)))
  rownames(mack_smry) <- NULL
  mack_smry <- data.frame(names(lob_triangle), mack_smry)
  names(mack_smry) <- c("GRCODE", "latest", "ultimate", "ibnr", "mack_se")
  mack_smry
}

paid_mack_smry <- lapply(paid_triangles, mack_f)
incurred_mack_smry <- lapply(incurred_triangles, mack_f)
```

```{r compare_mack_actual, echo = FALSE}

actual_ultimate <- function(lob, loss_type) {
  # find actual losses at development period 10
  # make individual function for this
  loss_col_name <- if (loss_type == "paid") {
     names(lob)[7]
   } else {
     names(lob)[6]
   }
  
  dev_10 <- lob[lob$DevelopmentLag == 10, ]
  tapply(dev_10[, loss_col_name], dev_10$GRCODE, sum)
}

paid_actual_ultimate <- lapply(data_sets, actual_ultimate, loss_type = "paid")
incurred_actual_ultimate <- lapply(data_sets, actual_ultimate, loss_type = "incurred")

# group actual losses with mack projections
mack_and_actual <- function(mack, actual) {
  mack_smry <- left_join(mack, actual, by = "GRCODE", copy = TRUE)
  names(mack_smry)[length(mack_smry)] <- "actual_ultimate"
  mutate(mack_smry, 
         actual_ibnr = actual_ultimate - latest,
         z = (acrual_ibnr - ibnr) / mack_se)
}

#paid_mack_full <- vector("list", length(paid_mack_smry))
#for (i in seq_along(paid_mack_smry)) {
#  paid_mack_full[[i]] <- mack_and_actual(paid_mack_smry[[i]], 
#                                         paid_actual_ultimate[[i]])
#}

#paid_mack_full
```

# Conclusions


# Appendix A: Paid Workers' Compensation Mack Method

\label{appendix:a}

### 1. Creating Triangles

First we need to make the triangles.  `triangle` is an S3 class from the `ChainLadder` package that we can create using the `as.triangle()` function.  The following is a triangle from one of the workers' compensation companies chosen at random.

```{r wc_paid_tri, echo = FALSE, results = "asis", echo = FALSE}
# isolate workers' compensation data
wkcomp_clean <- data_sets[[1]]

# find unique GRCODEs for looping
wkcomp_id <- unique(wkcomp_clean$GRCODE)

# create triangles for each company using `ChainLadder` package
paid_tri <- vector("list", length(wkcomp_id))
for (i in seq_along(wkcomp_id)) {
  paid_tri[[i]] <- as.triangle(wkcomp_clean[wkcomp_clean$GRCODE == wkcomp_id[i] & 
                                      wkcomp_clean$AccidentYear + 
                                      wkcomp_clean$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = "CumPaidLoss_D")
}


eg_paid_tri <- xtable(exhibit(paid_tri[[2]]),
                      digits = 0)
print(eg_paid_tri,
      format.args = list(big.mark = ","))
```

### 2. Run the Mack Method

We can apply the `ChainLadder` function `MackChainLadder()` to each of our triangles.  The following table is what the Mack method looks like applied to the triangle above.

```{r wc_mack, warning = FALSE, results = "asis", echo = FALSE}
# run mack model as provided in ChainLadder package
wc_mack <- lapply(paid_tri, MackChainLadder, est.sigma = "Mack")

# example of Mack method for company displayed in triangle above
eg_wc_mack <- xtable(exhibit(wc_mack[[2]]),
                      digits = c(0, 0, 2, 0, 0, 0))
print(eg_wc_mack,
      tabular.environment = 'longtable',
      floating = FALSE,
      format.args = list(big.mark = ","))
```


Now for all the workers' compensation companies in our analysis.

```{r wc_mack_smry, warning = FALSE, results = "asis", echo = FALSE}
# select relevant value for comparison to actual loss values
mack_smry <- vector("list", length(wc_mack))
for (i in seq_along(wc_mack)) {
  mack_smry[[i]] <- summary(wc_mack[[i]])[[2]]$Totals[c(1, 3:5)]
}

mack_smry <- as.data.frame(t(as.data.frame(mack_smry)))
rownames(mack_smry) <- NULL
mack_smry <- data.frame(wkcomp_id, mack_smry)
names(mack_smry) <- c("GRCODE", "latest", "ultimate", "ibnr", "mack_se")

# find actual losses at development period 10
actual_paid <- filter(wkcomp_clean, DevelopmentLag == 10) %>%
  group_by(GRCODE) %>%
  summarise(actual_ultimate = sum(CumPaidLoss_D))

# group actual losses with mack projections
mack_smry <- left_join(mack_smry, actual_paid, by = "GRCODE")
mack_smry <- mutate(mack_smry, actual_ibnr = actual_ultimate - latest)
mack_smry <- mack_smry[, -6]

# format data frame for printing
mack_smry_f <- xtable(mack_smry, digits = 0, 
                      align = "ccrrrrr",
                      display = c("d", "s", "d", "d", "d", "d", "d"))

# print data frame as LaTeX table
print(mack_smry_f,
      tabular.environment = 'longtable',
      floating = FALSE,
      include.rownames = FALSE,
      format.args = list(big.mark = ","))
```

### 3. Compare Mack Projections to Actual IBNR

Let's see how many of the actual IBNR amounts fell within 1 and 2 Mack S.E. of the projection.

```{r, echo = FALSE}
# compare absolute value of Mack projection - actual ultimate to mack se
out_one_se <- abs(mack_smry$ibnr - mack_smry$actual_ibnr) > 
                  mack_smry$mack_se
out_two_se <- abs(mack_smry$ibnr - mack_smry$actual_ibnr) > 
                 (mack_smry$mack_se * 2)

n <- nrow(mack_smry)

one_se <- (n - sum(out_one_se)) / n 
two_se <- (n - sum(out_two_se)) / n 
```

A quick review of the projections shows us that only `r round(one_se * 100, 1)`% of the actual insurence loss amounts were within one Mack S.E. of the projected ultimate loss amounts, and  `r round(two_se * 100, 1)`% were within two Mack S.E.

Let's investigate if the Mack IBNR projection has a tendency of being higher or lower than the actual IBNR.

```{r}
# review of companies outside two mack se
mack_smry$h_l <- (mack_smry$actual_ibnr - mack_smry$ibnr) / mack_smry$mack_se
  
mack_smry
```
