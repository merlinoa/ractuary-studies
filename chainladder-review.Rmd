---
title: "Mack and Boot ChainLadder Projections in Action"
author: "Andy Merlino"
date: "Wednesday, December 17, 2014"
output: 
    pdf_document:
        includes:
            in_header: mystyles.sty
fontsize: 12pt
geometry: margin=1.25in
---

# Purpose

To measure the accuracy of the Mack and Boot reserving methods available in the `ChainLadder` package by comparing the projections to actual insurance loss data.

# ChainLadder Package

The `ChainLadder` package by Markus Gesmann, Dan Murphy, and Wayne Zhang includes methods for projecting insurance loss reserves.  The Mack and Boot reserve projections are calculated by the `ChainLadder` functions, `MackChainLadder()` and `BootChainLadder()`.  For more information about the `ChainLadder` package please see the `ChainLadder` [package vignette](http://cran.r-project.org/web/packages/ChainLadder/vignettes/ChainLadder.pdf).  

# Data

The CAS website provides historic U.S. insurance loss data accross 6 different lines of business and many different companies.  The data includes all losses necessary to fill out a 10 by 10 matrix of losses grouped by origin year rows and development year columns for origin years 1988 through 1997.  We will use data from origin years 1988 through 1997 evaluated as of 1997 (i.e. the upper left triangle of losses) to run the `ChainLadder` projections.  The data will be projected out to the 10th development year and compared to actual loss data as of development year 10.  The CAS data sets include triangles as of 1997 and actual losses up to 2006, so we can compare the `ChainLadder` projections (calculated from data evaluated on data as of 1997) to actual losses after 10 development periods.  The CAS data sets include data from the following lines of business:

* Workers' Compensation
* Private Passenger Auto
* Commercial Auto
* Medical Malpractice
* Other Liability
* Product liability

For more information on the data see the [CAS webpage](http://www.casact.org/research/index.cfm?fa=loss_reserves_data).

```{r packages_data, message = FALSE, echo = FALSE}
library(ChainLadder) # install.packages("ChainLadder")
library(dplyr) # for data manipulation
library(reshape2) # data manipulation
library(ggplot2) # graphics
library(xtable) # tables
options(xtable.comment = FALSE)

# package I created to store CAS data
library(casdata) # devtools::install_github("merlinoa/casdata")
paid_cutoff <- 200
```

### A little data cleaning

A good portion of the companies in the data sets are missing losses for a portion of the origin years (e.g. for workers compensation 70 out of the 132 companies have a cumulative paid loss of zero for at least one origin year and development year).  In addition to companies with incomplete loss information I removed companies with cumulative paid losses of less than `r paid_cutoff` at any time because several of these companies were causing errors with the `ChainLadder` projection functions.  To see all the code used to create this report see the [.Rmd file on github](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd).

The following table breaks down of the number of companies included in this study by line of business.

```{r data_cleaning, echo = FALSE, results = "asis"}
# Combine data sets into a list data frame
wkcomp$lob <- "wkcomp"
ppauto$lob <- "ppauto"
prodliab$lob <- "prodliab"
comauto$lob <- "comauto"
medmal$lob <- "medmal"
othliab$lob <- "othliab"

names(ppauto) <- names(wkcomp)
names(prodliab) <- names(wkcomp)
names(comauto) <- names(wkcomp)
names(medmal) <- names(wkcomp)
names(othliab) <- names(wkcomp)

df <- rbind(wkcomp, ppauto, prodliab, comauto, medmal, othliab)
df$lob <- as.factor(df$lob)

# identify unique companies that have missing data.
# I also had some trouble with companies that had very small losses, so I decided
# to remove all companies with cumulative paid losses less than some value 
# at any observation in the data set.
# GRCODE is only unique by lob, so I need to create new column with combination of

df <- mutate(df, id = paste(lob, GRCODE, sep = "_"))
  
id_missing <- unique(df$id[df[, "CumPaidLoss_D"] <= paid_cutoff])

# remove companies that have missing data
df <- df[-which(df$id %in% id_missing), ]

df_out <- group_by(df, lob) %>%
  summarise(companies = length(unique(GRCODE)))

names(df_out) <- c("LOB", "No. of Companies")

df_out <- xtable(as.data.frame(df_out))

print(df_out,
      include.rownames = FALSE)
```

# Analysis

The analysis is done in R and, as far as I can tell, should be 100% reproducible assuming you have the appropriate free software installed on your computer.  The analysis takes each of the companies in the 6 lines of businesss represented in the CAS data sets, and runs the `MackChainLadder` and `BootChainLadder` reserve projection functions.  It then calculates the standard normal of the projections in relation to actual losses and plots the standard normals in histograms.  There are two histograms, one for the paid projection and one for the incurred projection, for each of the functions.  

Several steps are invloved in creating the desired visualizations from the cleaned data.  A simplified example of each of these steps for the Mack Method on paid workers' compensation losses is outlined in \hyperref[appendix:a]{Appendix A}. 

```{r create_triangles, echo = FALSE}
# function: to create triangles for each company
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
triangles <- function(data, loss_type) {

 # find unique GRCODEs for looping
 unique_id <- unique(data$id)
 
 # create triangles for each company using `ChainLadder` package
 tri <- vector("list", length(unique_id))
 for (i in seq_along(unique_id)) {
   tri[[i]] <- as.triangle(data[data$id == unique_id[i] & 
                                      data$AccidentYear + 
                                      data$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = loss_type)
 }
 # set name of each triangle to the id
 names(tri) <- unique_id
 tri
}

# use above functions to create paid and incurred triangles for all lines
# of business
paid_triangles <- triangles(df ,loss_type = "CumPaidLoss_D")
incurred_triangles <- triangles(df, loss_type = "IncurLoss_D")
```

```{r projections_functions, echo = FALSE, warning = FALSE}
# function for mack and boot projections============================================
# param triangles list of all company triangles
# param method character "MackChainLadder" or "BootChainLadder"
projection <- function(triangles, method) {
  # run mack model as provided in ChainLadder package 
  projections <- lapply(triangles, method)
  
  # extract the good stuff from the boot projection
  smry <- vector("list", length(projections))
  for (i in seq_along(projections)) {
    smry[[i]] <- summary(projections[[i]])[[2]]
  }

  smry <- as.data.frame(t(as.data.frame(smry)))
  rownames(smry) <- NULL
  smry <- data.frame(names(triangles), smry)
  smry$lob <- gsub("_.*$", "", smry[, 1])
  smry
}
```

```{r projection_actual_join, echo = FALSE}
# function: to find the sum of actual losses for all origin years for 
# each insurance company after 10 development periods
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
actual_ultimate <- function(data, loss_type) {
  # find actual losses at development period 10
  dev_10 <- data[data$DevelopmentLag == 10, ]
  dev_10_sum <- as.data.frame(tapply(dev_10[, loss_type], dev_10$id,  sum))
  dev_10_sum$id <- rownames(dev_10_sum)
  names(dev_10_sum)[1] <- paste0(loss_type, "_ultimate")
  dev_10_sum
}

# run function to find actual ultimates for all companies
paid_actual_ultimate <- actual_ultimate(df, loss_type = "CumPaidLoss_D")
incurred_actual_ultimate <- actual_ultimate(df, loss_type = "IncurLoss_D")

# group actual losses with mack projections
projection_actual_join <- function(projection_smry, actual) {
  smry <- left_join(projection_smry, actual, by = "id", copy = TRUE)
  names(smry)[length(smry)] <- "actual_ultimate"
  # calculate z value
  smry$actual_ibnr <-  smry$actual_ultimate - smry$latest
  smry$z = (smry$actual_ibnr - smry$ibnr) / smry$se
  smry
}
```

\pagebreak

## The Mack Method

The Mack Method provides a distribution free calculation of the standard error for the standard chain ladder IBNR projection.

```{r mack, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# calculate mack projections and grab summary
paid_mack_smry <- projection(paid_triangles, 
                             method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(paid_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_mack_smry <- projection(incurred_triangles, 
                                 method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(incurred_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_mack_full <- projection_actual_join(paid_mack_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_mack_full <- projection_actual_join(incurred_mack_smry, 
                                      incurred_actual_ultimate)

# plot paid mack z values
ggplot(paid_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("MackChainLadder - Paid Projection") +
       geom_bar()

# plot incurred mack z values
ggplot(incurred_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("MackChainLadder - Incurred Projection") +
       geom_bar()
```

# The Bootstrap Method

Uses bootstap resampling to determine the standard error.

```{r boot_projections, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# caculate and return summary info for bootstrap method
paid_boot_smry <- projection(paid_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(paid_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_boot_smry <- projection(incurred_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(incurred_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_boot_full <- projection_actual_join(paid_boot_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_boot_full <- projection_actual_join(incurred_boot_smry, 
                                      incurred_actual_ultimate)

# plot paid boot z values
ggplot(paid_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("BootChainLadder - Paid Projection") +
       geom_bar()

# plot incurred boot z values
ggplot(incurred_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("BootChainLadder - Incurred Projection") +
       geom_bar()
```

WOW! The `BootChainLadder()` function on incurred projection performs better than projections normally distributed around the actual losses!? ... could that be right?

# Take Aways

The paid IBNR projections appear to slightly underestimate the actual IBNR.  The incurred IBNR projections tend to be more centralized around the actual IBNR.

The `BootChainLadder()` function on incurred losses gave surprisingly accurate IBNR projections.  I will need to dig deeper to find out why it is performing so well.

\pagebreak

# Appendix A: Paid Workers' Compensation Mack Method - An Example

\label{appendix:a}

### 1. Creating Triangles

First we need to make the triangle for each company.  `triangle` is an S3 class from the `ChainLadder` package that we can create using the `as.triangle()` function.  The following is a triangle from one of the workers' compensation companies chosen at random.

```{r wc_paid_tri, echo = FALSE, results = "asis"}
# package I created to transform ChainLadder classes into
# data frames that can be easily printed to pdf
library(exhibit) # devtools::install_github("merlinoa/exhibit")

# select GRCODE of company we want to use
grcode <- 337

# isolate one workers' compensation company
wc337 <- df[df$lob == "wkcomp" & df$GRCODE == grcode, ]

# create triangles for each company using `ChainLadder` package
wc337_paid_tri <- as.triangle(wc337[wc337$AccidentYear + 
                                    wc337$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = "CumPaidLoss_D")

# prepare triangle for printing
wc337_paid_tri_out <- xtable(exhibit(wc337_paid_tri),
                      digits = 0)

# print triangle
print(wc337_paid_tri_out,
      format.args = list(big.mark = ","))
```

### 2. Run the Mack Method

Next we apply the projection function to triangle for our each company.  The following is a summary of the `MackChainLadder()` function applied to the company in the triangle above.

```{r wc_mack, warning = FALSE, results = "asis", echo = FALSE}
# run mack model as provided in ChainLadder package
wc337_mack <- MackChainLadder(wc337_paid_tri)

# example of Mack method for company displayed in triangle above
wc337_mack_out <- xtable(exhibit(wc337_mack),
                         digits = c(0, 0, 2, 0, 0, 0))
print(wc337_mack_out,
      format.args = list(big.mark = ","))
```

### 3. Compare Mack Projections to Actual Losses

We are interested in the `IBNR` and `Mack SE` from the `Totals` row in the table above.  The totals for this workers' compensation company along with the actual IBNR is shown in the following table.  We compare the Mack projections to the actual IBNR to get the `Z` column , $Z=\frac{(Mack IBNR)-(Actual IBNR)}{(Mack SE)}$.  The `Z` column for each company is the value plotted in the histograms in the analysis.

```{r wc_mack_smry, warning = FALSE, echo = FALSE, results = "asis"}
# select relevant value for comparison to actual loss values
wc337_mack_smry <- summary(wc337_mack)[[2]]$Totals[c(1, 3:5)]

# transform into data frame
wc337_mack_smry <- as.data.frame(t(as.data.frame(wc337_mack_smry)))
rownames(wc337_mack_smry) <- NULL
wc337_mack_smry <- data.frame(grcode, wc337_mack_smry)
names(wc337_mack_smry) <- c("GRCODE", "latest", "mack_ultimate", "mack_ibnr", "mack_se")

# find actual losses at development period 10
actual_paid <- filter(wc337, DevelopmentLag == 10) %>%
  group_by(GRCODE) %>%
  summarise(actual_paid = sum(CumPaidLoss_D))
actual_paid <- actual_paid$actual_paid

# group actual losses with mack projections
wc337_mack_smry$actual_ibnr <- actual_paid - wc337_mack_smry$latest

# calculate z value
wc337_mack_smry$z <- (wc337_mack_smry$actual_ibnr - wc337_mack_smry$mack_ibnr) / wc337_mack_smry$mack_se

wc337_mack_smry_out <- wc337_mack_smry[, c(1, 4:7)]
names(wc337_mack_smry_out) <- c("GRCODE", "Mack IBNR", "Mack S.E.", "Actual IBNR", "Z")

# format data frame for printing
wc337_mack_smry_out <- xtable(wc337_mack_smry_out, 
                              digits = c(0, 0, 0, 0, 0, 2),
                              align = "ccrrrr",
                              display = c("f","s", "f", "f", "f", "f"))

# print data frame as LaTeX table
print(wc337_mack_smry_out, 
      include.rownames = FALSE,
      format.args = list(big.mark = ","))
```