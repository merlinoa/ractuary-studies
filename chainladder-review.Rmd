---
title: "ChainLadder Package in Action"
author: "Andy Merlino"
date: "Friday, December 12, 2014"
output: 
    pdf_document:
        includes:
            in_header: mystyles.sty
fontsize: 12pt
geometry: margin=1.25in
---

# Background

The `ChainLadder` package by Markus Gesmann, Dan, Murphy, and Wayne Zhang includes methods for projecting insurance loss reserves.  For more information about the `ChainLadder` package please see the `ChainLadder` [package vignette](http://cran.r-project.org/web/packages/ChainLadder/vignettes/ChainLadder.pdf).  

# Purpose

This document aims to measure the accuracy of the different reserving methods available in the `ChainLadder` package by comparing the package projections to actual insurance loss data.

# Data

The CAS website provides historic U.S. insurance loss data accross 6 different lines of business and many different companies.  The data includes complete triangles from origin years 1988 through 1997.  We will use data from origin years 1988 through 1997 evaluated as of 1997 to run the `ChainLadder` projections.  The data will be projected out to the 10th development year and compared to actual loss data as of development period 10.  The CAS data sets include triangles as of 1997 and actual losses up to 2011, so we can compare the `ChainLadder` projections (evaluated on data as of 1997) and compare it to actual losses after 10 development periods.  The CAS data sets include data from the following lines of business:

* Workers' Compensation
* Private Passenger Auto
* Commercial Auto
* Medical Malpractice
* Other Liability
* Product liability

For more information on the data see the [CAS webpage](http://www.casact.org/research/index.cfm?fa=loss_reserves_data).

```{r packages_data, message = FALSE, echo = FALSE}
library(ChainLadder) # install.packages("ChainLadder")
library(dplyr) # for data manipulation
library(reshape2) # data manipulation
library(ggplot2)
library(xtable)
options(xtable.comment = FALSE)

# package I created to store CAS data
library(casdata) # devtools::install_github("merlinoa/casdata")
# package I created to transform ChainLadder classes into
# data frames that can be easily printed to pdf
library(exhibit) # devtools::install_github("merlinoa/exhibit")
paid_cutoff <- 200
```

### A little data cleaning

A good portion of the companies in the data sets are missing losses for a portion of the origin years (e.g. for workers compensation 70 out of the 132 companies have a cumulative paid loss of zero for at least one origin year and development period).  In addition to companies with incomplete loss information we removed companies with cumulative paid losses of less than `r paid_cutoff` at any time because many of these companies were causing errors with the `ChainLadder` projection functions.  To see all the code used to create this report see the [.Rmd file on github](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd).

```{r data_cleaning, echo = FALSE}
# Combine data sets into a list data frame
wkcomp$lob <- "wkcomp"
ppauto$lob <- "ppauto"
prodliab$lob <- "prodliab"
comauto$lob <- "comauto"
medmal$lob <- "medmal"
othliab$lob <- "othliab"

names(ppauto) <- names(wkcomp)
names(prodliab) <- names(wkcomp)
names(comauto) <- names(wkcomp)
names(medmal) <- names(wkcomp)
names(othliab) <- names(wkcomp)

df <- rbind(wkcomp, ppauto, prodliab, comauto, medmal, othliab)
df$lob <- as.factor(df$lob)

# identify unique companies that have missing data.
# I also had some trouble with companies that had very small losses, so I decided
# to remove all companies with cumulative paid losses less than some value 
# at any observation in the data set.
# GRCODE is only unique by lob, so I need to create new column with combination of

df <- mutate(df, id = paste(lob, GRCODE, sep = "_"))
  
id_missing <- unique(df$id[df[, "CumPaidLoss_D"] <= 200])

# remove companies that have missing data
df <- df[-which(df$id %in% id_missing), ]
```

# Analysis

The analysis is done in R and, as far as I can tell, should be 100% reproducible assuming you have the appropriate free software installed on your computer.  The analysis takes each of the companies in the 6 lines of businesss represented in the CAS data sets, and runs several `ChainLadder` reserve projection functions.  It then calculates the standard normal of the projections in relation to actual losses and plots the standard normals in histograms.  There are two histograms, one for the paid projection and one for the incurred projection, for each `ChainLadder` function covered in this document.  

Several steps are invloved in creating the desired visualizations from the cleaned data.  An example of each of these steps for the Mack Method on paid workers' compensation losses is outlined in \hyperref[appendix:a]{Appendix A}. 

```{r create_triangles, echo = FALSE}
# param data the cleaned insurance loss data frame
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
triangles <- function(data, loss_type) {

 # find unique GRCODEs for looping
 unique_id <- unique(data$id)
 
 # create triangles for each company using `ChainLadder` package
 tri <- vector("list", length(unique_id))
 for (i in seq_along(unique_id)) {
   tri[[i]] <- as.triangle(data[data$id == unique_id[i] & 
                                      data$AccidentYear + 
                                      data$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = loss_type)
 }
 # set name of each triangle to the id
 names(tri) <- unique_id
 tri
}

# use above functions to create paid and incurred triangles for all lines
# of business
paid_triangles <- triangles(df ,loss_type = "CumPaidLoss_D")
incurred_triangles <- triangles(df, loss_type = "IncurLoss_D")
```

```{r projections_functions, echo = FALSE, warning = FALSE}
# function for mack and boot projections============================================
# param triangles list of all company triangles
projection <- function(triangles, method) {
  # run mack model as provided in ChainLadder package 
  projections <- lapply(triangles, method)
  
  # extract the good stuff from the boot projection
  smry <- vector("list", length(projections))
  for (i in seq_along(projections)) {
    smry[[i]] <- summary(projections[[i]])[[2]]
  }

  smry <- as.data.frame(t(as.data.frame(smry)))
  rownames(smry) <- NULL
  smry <- data.frame(names(triangles), smry)
  smry$lob <- gsub("_.*$", "", smry[, 1])
  smry
}
```

```{r projection_actual_join, echo = FALSE}
actual_ultimate <- function(data, loss_type) {
  # find actual losses at development period 10
  dev_10 <- data[data$DevelopmentLag == 10, ]
  dev_10_sum <- as.data.frame(tapply(dev_10[, loss_type], dev_10$id,  sum))
  dev_10_sum$id <- rownames(dev_10_sum)
  names(dev_10_sum)[1] <- paste0(loss_type, "_ultimate")
  dev_10_sum
}

# find actual ultimates for all companies
paid_actual_ultimate <- actual_ultimate(df, loss_type = "CumPaidLoss_D")
incurred_actual_ultimate <- actual_ultimate(df, loss_type = "IncurLoss_D")

# group actual losses with mack projections
projection_actual_join <- function(projection_smry, actual) {
  smry <- left_join(projection_smry, actual, by = "id", copy = TRUE)
  names(smry)[length(smry)] <- "actual_ultimate"
  # calculate z value
  smry$actual_ibnr <-  smry$actual_ultimate - smry$latest
  smry$z = (smry$actual_ibnr - smry$ibnr) / smry$se
  smry
}
```

\pagebreak

## The Mack Method

The Mack Method provides a distribution free calculation of the standard error for the standard chain ladder IBNR projection.

```{r mack, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# calculate mack projections and grab summary
paid_mack_smry <- projection(paid_triangles, 
                             method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(paid_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_mack_smry <- projection(incurred_triangles, 
                                 method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(incurred_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_mack_full <- projection_actual_join(paid_mack_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_mack_full <- projection_actual_join(incurred_mack_smry, 
                                      incurred_actual_ultimate)

# plot paid mack z values
ggplot(paid_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("MackChainLadder - Paid Projection") +
       geom_bar()

# plot incurred mack z values
ggplot(incurred_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("MackChainLadder - Incurred Projection") +
       geom_bar()
```

# The Bootstrap Method

Uses bootstap resampling to determine the standard error.

```{r boot_projections, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# caculate and return summary info for bootstrap method
paid_boot_smry <- projection(paid_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(paid_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_boot_smry <- projection(incurred_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(incurred_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_boot_full <- projection_actual_join(paid_boot_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_boot_full <- projection_actual_join(incurred_boot_smry, 
                                      incurred_actual_ultimate)

# plot paid boot z values
ggplot(paid_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("BootChainLadder - Paid Projection") +
       geom_bar()

# plot incurred boot z values
ggplot(incurred_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("BootChainLadder - Incurred Projection") +
       geom_bar()
```

WOW! The `BootChainLadder()` function on incurred data performs really really well!

# Munich Chain Ladder Method

The Munich Method uses the ratio of paid to incurred to adjust the paid and incurred chain ladder estimates.

The Munich projection for 10 of the companies does not work, and throws an error.  Many of the other companies get very poor or infinite estimates.  Not sure what the problem is yet...

```{r munich_projections, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# munich projection not working for the following triangles.
# removing these triangle for munich projections computation
paid_triangles_munich <- paid_triangles[-c(49, 72, 76, 88, 89, 90, 96, 101, 107, 153)]
incurred_triangles_munich <- incurred_triangles[-c(49, 72, 76, 88, 89, 90, 96, 101, 107, 153)]

# caculate and return summary info for bootstrap method
munich_projections <- vector("list", length(paid_triangles_munich))
for (i in seq_along(paid_triangles_munich)) {
  munich_projections[[i]] <- MunichChainLadder(Paid = paid_triangles_munich[[i]], 
                                               Incurred = incurred_triangles_munich[[i]])
}

paid_munich_smry <- vector("list", length(munich_projections))
for (i in seq_along(paid_munich_smry)) {
  latest <- summary(munich_projections[[i]])[[2]][1, 1]
  ultimate <- summary(munich_projections[[i]])[[2]][2, 1]
  se <- munich_projections[[i]][[6]][[2]][[5]]
  paid_munich_smry[[i]] <- c("id" = names(paid_triangles_munich)[i],
                             latest, ultimate, 
                             "ibnr" = ultimate - latest,
                             se)
}

paid_munich_smry <- as.data.frame(t(as.data.frame(paid_munich_smry)))
paid_munich_smry$lob <- gsub("_.*$", "", paid_munich_smry[, 1])
rownames(paid_munich_smry) <- NULL

#incurred_munich_smry <- vactor("list", length(munich_projections))
#for (i in seq_along(munich_smry)) {
#  latest <- munich_projections[[i]][[1]][[2]][1, 2]
#  ultimate <- munich_projections[[i]][[1]][[2]][2, 2]
#  se <- munich_projections[[i]][[7]][[2]][[5]]
#  incurred_munich_smry[[i]] <- c(latest, ultimate, se)
#}
  

names(paid_munich_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid munich projections with actual
factor2numeric <- function(x) as.numeric(as.character(x))
paid_munich_smry[, 2:5] <- apply(paid_munich_smry[, 2:5], 2, factor2numeric)
paid_munich_full <- projection_actual_join(paid_munich_smry, paid_actual_ultimate)


# plot paid munich z values
ggplot(paid_munich_full[paid_munich_full$z > -100 & paid_munich_full$z < 100, ], aes(x = z, fill = lob)) +
       geom_histogram(colour = "black")
```

# Conclusions

This analysis is not complete, but so far the `BootChainLadder()` function on incurred losses has been the best performer by far.  I will need to dig deeper to find out why it is performing so well.

\pagebreak

# Appendix A: Paid Workers' Compensation Mack Method - An Example

\label{appendix:a}

### 1. Creating Triangles

First we need to make the triangles.  `triangle` is an S3 class from the `ChainLadder` package that we can create using the `as.triangle()` function.  The following is a triangle from one of the workers' compensation companies chosen at random.

```{r wc_paid_tri, echo = FALSE, results = "asis"}
# isolate workers' compensation data
wkcomp_clean <- df[df$lob == "wkcomp", ]

# find unique GRCODEs for looping
wkcomp_id <- unique(wkcomp_clean$GRCODE)

# create triangles for each company using `ChainLadder` package
paid_tri <- vector("list", length(wkcomp_id))
for (i in seq_along(wkcomp_id)) {
  paid_tri[[i]] <- as.triangle(wkcomp_clean[wkcomp_clean$GRCODE == wkcomp_id[i] & 
                                      wkcomp_clean$AccidentYear + 
                                      wkcomp_clean$DevelopmentLag < 1999, ], 
                               origin = "AccidentYear", 
                               dev = "DevelopmentLag", 
                               value = "CumPaidLoss_D")
}


eg_paid_tri <- xtable(exhibit(paid_tri[[2]]),
                      digits = 0)
print(eg_paid_tri,
      format.args = list(big.mark = ","))
```

### 2. Run the Mack Method

We can apply the `ChainLadder` function `MackChainLadder()` to each of our triangles.  The following table is a summary of the `MackChainLadder()` function applied to the company from the triangle above.

```{r wc_mack, warning = FALSE, results = "asis", echo = FALSE}
# run mack model as provided in ChainLadder package
wc_mack <- lapply(paid_tri, MackChainLadder, est.sigma = "Mack")

# example of Mack method for company displayed in triangle above
eg_wc_mack <- xtable(exhibit(wc_mack[[2]]),
                      digits = c(0, 0, 2, 0, 0, 0))
print(eg_wc_mack,
      tabular.environment = 'longtable',
      floating = FALSE,
      format.args = list(big.mark = ","))
```

### 3. Compare Mack Projections to Actual Losses

We are interested in the `Totals` row `mack_ibnr` and `mack_se` from the table above for each company.  A summary of the totals for a few of the workers' compensation companies along with the actual IBNR for each company is shown in the following table.  Notice that the company we looked at in the above tables is in row 2 of the following table.  We compare the Mack projections to the actual ultimate to get the `z` column , $z=\frac{mack_ibnr-actual_ibnr}{mack_se}$.  The `z` column is the value plotted in the histograms.

```{r wc_mack_smry, warning = FALSE, results = "asis", echo = FALSE}
# select relevant value for comparison to actual loss values
mack_smry <- vector("list", length(wc_mack))
for (i in seq_along(wc_mack)) {
  mack_smry[[i]] <- summary(wc_mack[[i]])[[2]]$Totals[c(1, 3:5)]
}

mack_smry <- as.data.frame(t(as.data.frame(mack_smry)))
rownames(mack_smry) <- NULL
mack_smry <- data.frame(wkcomp_id, mack_smry)
names(mack_smry) <- c("GRCODE", "latest", "mack_ultimate", "mack_ibnr", "mack_se")

# find actual losses at development period 10
actual_paid <- filter(wkcomp_clean, DevelopmentLag == 10) %>%
  group_by(GRCODE) %>%
  summarise(actual_ultimate = sum(CumPaidLoss_D))

# group actual losses with mack projections
mack_smry <- left_join(mack_smry, actual_paid, by = "GRCODE")
mack_smry <- mutate(mack_smry, actual_ibnr = actual_ultimate - latest)
mack_smry <- mack_smry[, -6]


# calculate z value
mack_smry$z <- (mack_smry$actual_ibnr - mack_smry$mack_ibnr) / mack_smry$mack_se

# format data frame for printing
mack_smry_f <- xtable(mack_smry[1:10, c(1, 4:7)], 
                      digits = c(0, 0, 0, 0, 0, 2),
                      align = "ccrrrr",
                      display = c("f","s", "f", "f", "f", "f"))

# print data frame as LaTeX table
print(mack_smry_f, 
      include.rownames = FALSE,
      tabular.environment = 'longtable',
      floating = FALSE,
      format.args = list(big.mark = ","))
```