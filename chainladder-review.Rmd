---
title: "Mack and Boot ChainLadder Projections in Action"
author: "Andy Merlino"
date: "2015-02-23"
output: html_document
fontsize: 12pt
geometry: margin=1.25in
---

# Purpose

Measure the accuracy of the `ChainLadder::MackChainLadder()` and `ChainLadder::BootChainLadder()` reserve projection functions by comparing the projected reserves to actual insurance losses.

# ChainLadder Package

The `ChainLadder` package by Markus Gesmann, Dan Murphy, and Wayne Zhang includes methods for projecting insurance loss reserves.  The Mack and Boot reserve projections are calculated by the `ChainLadder` functions, `MackChainLadder()` and `BootChainLadder()`.  For more information about the `ChainLadder` package please see the `ChainLadder` [package vignette](http://cran.r-project.org/web/packages/ChainLadder/vignettes/ChainLadder.pdf).  

# Data

The CAS website provides historic U.S. insurance loss data accross 6 different lines of business and many different companies.  I used the data from origin years 1988 through 1997 evaluated as of 1997 (i.e. the upper left triangle of losses) to run the `ChainLadder` projections.  The CAS data sets includes actual losses developed for 10 years for all the provided origin years.  The CAS data sets include data from the following lines of business:

* Workers' Compensation
* Private Passenger Auto
* Commercial Auto
* Medical Malpractice
* Other Liability
* Product liability

For more information on the data see the [CAS webpage](http://www.casact.org/research/index.cfm?fa=loss_reserves_data).

```{r packages_data, message = FALSE, echo = FALSE}
library(ChainLadder) # install.packages("ChainLadder")
library(dplyr) # for data manipulation
library(reshape2) # data manipulation
library(ggplot2) # graphics
library(xtable) # tables
options(xtable.comment = FALSE)
options(xtable.type = "html")

# package I created to store CAS data
library(casdata) # devtools::install_github("merlinoa/casdata")
paid_cutoff <- 200
```

### A little data cleaning

Several companies were removed from the analysis for various reasons.  The most common reason I removed a company from the analysis was that it had incomplete loss information.  To see all the code used to clean the data see the [.Rmd file on github](https://raw.githubusercontent.com/merlinoa/ractuary-studies/master/chainladder-review.Rmd).

The following table breaks down the number of companies included in this study by line of business.

```{r data_cleaning, echo = FALSE, results = "asis"}
# identify unique companies that have missing data.
# I also had some trouble with companies that had very small losses, so I decided
# to remove all companies with cumulative paid losses less than some value 
# at any observation in the data set.
# GRCODE is only unique by lob, so I need to create new column with combination of

df <- mutate(losses, id = paste(lob, gr_code, sep = "_"))
  
id_missing <- unique(df$id[df[, "paid"] <= paid_cutoff])

# remove companies that have missing data
df <- df[-which(df$id %in% id_missing), ]

df_out <- group_by(df, lob) %>%
  summarise(companies = length(unique(gr_code)))

names(df_out) <- c("LOB", "Num of Companies")

df_out <- xtable(as.data.frame(df_out))

print(df_out,
      include.rownames = FALSE)
```

# Analysis

The analysis runs the `MackChainLadder` and `BootChainLadder` reserve projection functions on each company.  We then identify what the true reserve should have been and we subtract the projected reserve amount from the true reserve and then divide that by the standard error estimated by each reserving function.

Several steps are invloved in creating the desired visualizations from the cleaned data.  A simplified example of each of these steps for the Mack Method on paid workers' compensation losses is outlined in \hyperref[appendix:a]{Appendix A}.

```{r create_triangles, echo = FALSE}
# function: to create triangles for each company
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
triangles <- function(data, loss_type) {

 # find unique GRCODEs for looping
 unique_id <- unique(data$id)
 
 # create triangles for each company using `ChainLadder` package
 tri <- vector("list", length(unique_id))
 for (i in seq_along(unique_id)) {
   tri[[i]] <- as.triangle(data[data$id == unique_id[i] & 
                                      data$origin + 
                                      data$dev < 1999, ], 
                               origin = "origin", 
                               dev = "dev", 
                               value = loss_type)
 }
 # set name of each triangle to the id
 names(tri) <- unique_id
 tri
}

# use above functions to create paid and incurred triangles for all lines
# of business
paid_triangles <- triangles(df ,loss_type = "paid")
incurred_triangles <- triangles(df, loss_type = "incurred")
```

```{r projections_functions, echo = FALSE, warning = FALSE}
# function for mack and boot projections============================================
# param triangles list of all company triangles
# param method character "MackChainLadder" or "BootChainLadder"
projection <- function(triangles, method) {
  # run mack model as provided in ChainLadder package 
  projections <- lapply(triangles, method)
  
  # extract the good stuff from the boot projection
  smry <- vector("list", length(projections))
  for (i in seq_along(projections)) {
    smry[[i]] <- summary(projections[[i]])[[2]]
  }

  smry <- as.data.frame(t(as.data.frame(smry)))
  rownames(smry) <- NULL
  smry <- data.frame(names(triangles), smry)
  smry$lob <- gsub("_.*$", "", smry[, 1])
  smry
}
```

```{r projection_actual_join, echo = FALSE}
# function: to find the sum of actual losses for all origin years for 
# each insurance company after 10 development periods
# param data the cleaned insurance loss data frame; `df`
# param loss_type character "CumPaidLoss_D" or "IncurLoss_D"
actual_ultimate <- function(data, loss_type) {
  # find actual losses at development period 10
  dev_10 <- data[data$dev == 10, ]
  dev_10_sum <- as.data.frame(tapply(dev_10[, loss_type], dev_10$id,  sum))
  dev_10_sum$id <- rownames(dev_10_sum)
  names(dev_10_sum)[1] <- paste0(loss_type, "_ultimate")
  dev_10_sum
}

# run function to find actual ultimates for all companies
paid_actual_ultimate <- actual_ultimate(df, loss_type = "paid")
incurred_actual_ultimate <- actual_ultimate(df, loss_type = "incurred")

# group actual losses with mack projections
projection_actual_join <- function(projection_smry, actual) {
  smry <- left_join(projection_smry, actual, by = "id", copy = TRUE)
  names(smry)[length(smry)] <- "actual_ultimate"
  # calculate z value
  smry$actual_ibnr <-  smry$actual_ultimate - smry$latest
  smry$z = (smry$actual_ibnr - smry$ibnr) / smry$se
  smry
}
```

\pagebreak

## The Mack Method

The Mack Method provides a distribution free calculation of the standard error for the standard chain ladder IBNR projection.

```{r mack, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# calculate mack projections and grab summary
paid_mack_smry <- projection(paid_triangles, 
                             method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(paid_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_mack_smry <- projection(incurred_triangles, 
                                 method = "MackChainLadder")[, c(1, 2, 4, 5, 6, 8)]
names(incurred_mack_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_mack_full <- projection_actual_join(paid_mack_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_mack_full <- projection_actual_join(incurred_mack_smry, 
                                      incurred_actual_ultimate)

# plot paid mack z values
ggplot(paid_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("MackChainLadder - Paid Projection") +
       geom_bar()

# plot incurred mack z values
ggplot(incurred_mack_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("MackChainLadder - Incurred Projection") +
       geom_bar()
```

# The Bootstrap Method

Uses bootstap resampling to determine the standard error.

```{r boot_projections, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 4}
# caculate and return summary info for bootstrap method
paid_boot_smry <- projection(paid_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(paid_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

incurred_boot_smry <- projection(incurred_triangles, method = "BootChainLadder")[, c(1, 2:5, 8)]
names(incurred_boot_smry) <- c("id", "latest", "ultimate", "ibnr", "se", "lob")

# combine paid mack projections with actual
paid_boot_full <- projection_actual_join(paid_boot_smry, paid_actual_ultimate)

# combine incurred mack projections with actuals
incurred_boot_full <- projection_actual_join(incurred_boot_smry, 
                                      incurred_actual_ultimate)

# plot paid boot z values
ggplot(paid_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") +
       ggtitle("BootChainLadder - Paid Projection") +
       geom_bar()

# plot incurred boot z values
ggplot(incurred_boot_full, aes(x = z, fill = lob)) +
       geom_histogram(colour = "black") +
       xlab("Standard Normal") + 
       ggtitle("BootChainLadder - Incurred Projection") +
       geom_bar()
```

The `BootChainLadder()` function on incurred projection performs better than projections normally distributed around the actual losses!? ... could that be right?

# Take Aways

The paid IBNR projections appear to slightly underestimate the actual IBNR.  The incurred IBNR projections tend to be more centralized around the actual IBNR.

The `BootChainLadder()` function on incurred losses gave surprisingly accurate IBNR projections.  I will need to dig deeper to find out why it is performing so well.

\pagebreak

# Appendix A: Paid Workers' Compensation Mack Method - An Example

\label{appendix:a}

### 1. Creating Triangles

First we need to make the triangle for each company.  `triangle` is an S3 class from the `ChainLadder` package that we can create using the `as.triangle()` function.  The following is a triangle from one of the workers' compensation companies chosen at random.

```{r wc_paid_tri, echo = FALSE, results = "asis"}
# package I created to transform ChainLadder classes into
# data frames that can be easily printed to pdf
library(exhibit) # devtools::install_github("merlinoa/exhibit")

# select GRCODE of company we want to use
grcode <- 337

# isolate one workers' compensation company
wc337 <- df[df$lob == "wkcomp" & df$gr_code == grcode, ]

# create triangles for each company using `ChainLadder` package
wc337_paid_tri <- as.triangle(wc337[wc337$origin + 
                                    wc337$dev < 1999, ], 
                               origin = "origin", 
                               dev = "dev", 
                               value = "paid")

# prepare triangle for printing
wc337_paid_tri_out <- xtable(exhibit(wc337_paid_tri),
                      digits = 0)

# print triangle
print(wc337_paid_tri_out,
      format.args = list(big.mark = ","))
```

### 2. Run the Mack Method

Next we apply the projection function to triangle for our each company.  The following is a summary of the `MackChainLadder()` function applied to the company in the triangle above.

```{r wc_mack, warning = FALSE, results = "asis", echo = FALSE}
# run mack model as provided in ChainLadder package
wc337_mack <- MackChainLadder(wc337_paid_tri)

# example of Mack method for company displayed in triangle above
wc337_mack_out <- xtable(exhibit(wc337_mack),
                         digits = c(0, 0, 2, 0, 0, 0))
print(wc337_mack_out,
      format.args = list(big.mark = ","))
```

### 3. Compare Mack Projections to Actual Losses

We are interested in the `IBNR` and `Mack SE` from the `Totals` row in the table above.  The totals for this workers' compensation company along with the actual IBNR is shown in the following table.  We compare the Mack projections to the actual IBNR to get the `Z` column , $Z=\frac{(Mack IBNR)-(Actual IBNR)}{(Mack SE)}$.  The `Z` column for each company is the value plotted in the histograms in the analysis.

```{r wc_mack_smry, warning = FALSE, echo = FALSE, results = "asis"}
# select relevant value for comparison to actual loss values
wc337_mack_smry <- summary(wc337_mack)[[2]]$Totals[c(1, 3:5)]

# transform into data frame
wc337_mack_smry <- as.data.frame(t(as.data.frame(wc337_mack_smry)))
rownames(wc337_mack_smry) <- NULL
wc337_mack_smry <- data.frame(grcode, wc337_mack_smry)
names(wc337_mack_smry) <- c("GRCODE", "latest", "mack_ultimate", "mack_ibnr", "mack_se")

# find actual losses at development period 10
actual_paid <- filter(wc337, dev == 10) %>%
  group_by(gr_code) %>%
  summarise(actual_paid = sum(paid))
actual_paid <- actual_paid$actual_paid

# group actual losses with mack projections
wc337_mack_smry$actual_ibnr <- actual_paid - wc337_mack_smry$latest

# calculate z value
wc337_mack_smry$z <- (wc337_mack_smry$actual_ibnr - wc337_mack_smry$mack_ibnr) / wc337_mack_smry$mack_se

wc337_mack_smry_out <- wc337_mack_smry[, c(1, 4:7)]
names(wc337_mack_smry_out) <- c("GRCODE", "Mack IBNR", "Mack S.E.", "Actual IBNR", "Z")

# format data frame for printing
wc337_mack_smry_out <- xtable(wc337_mack_smry_out, 
                              digits = c(0, 0, 0, 0, 0, 2),
                              align = "ccrrrr",
                              display = c("f","s", "f", "f", "f", "f"))

# print data frame as LaTeX table
print(wc337_mack_smry_out, 
      include.rownames = FALSE,
      format.args = list(big.mark = ","))
```